<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | everything's interesting]]></title>
  <link href="http://aerenchyma.github.com/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://aerenchyma.github.com/"/>
  <updated>2013-10-21T15:26:52-04:00</updated>
  <id>http://aerenchyma.github.com/</id>
  <author>
    <name><![CDATA[Jackie Cohen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[remote lighting]]></title>
    <link href="http://aerenchyma.github.com/blog/2013/04/21/remote-lighting/"/>
    <updated>2013-04-21T12:01:00-04:00</updated>
    <id>http://aerenchyma.github.com/blog/2013/04/21/remote-lighting</id>
    <content type="html"><![CDATA[<p>This past Friday, I joined forces with a friend for a fun remote lighting project using a Raspberry Pi.</p>

<p>Remote lighting? you say. You know the colored stage lights you see in theatres? If you ever did tech for a production in high school in a small theatre without super-intense equipment, those are the ones we used. They were hooked up via <a href="http://en.wikipedia.org/wiki/DMX_(lighting">DMX</a> ). (See <a href="http://www.opendmx.net/index.php/OLA_Python_API">here</a> for more information about the Python API, which we used.)</p>

<p>Some of these lights were hooked up to a Pi, and the idea was that we would be able to pass a color (e.g. on a color wheel like you might see in Photoshop), and brightness, via a web interface, which would then set the lights on as specified.</p>

<p>Below is the how and the what, and the code. All you need to make this happen is the appropriate lights and wiring (I didn't do this part, so I can't speak to it), a Raspberry Pi, set up with wireless, and a computer with monitor and keyboard input/a laptop that can also access the wireless network.</p>

<!--more-->


<h2>the setup</h2>

<p>We had 4 "normal" lights, and 1 special case light. Each of the four normal lights had four input/output channels. The fifth "special case" light had five channels.</p>

<p>All of them had channels <code>brightness</code>, <code>red</code>, <code>blue</code>, and <code>green</code>. The special case light (a light sort of but not exactly like <a href="http://www.alibaba.com/product-gs/693385417/DMX_18x10W_RGBW_4IN1_Multi_color.html">this</a>) had these four channels, plus a <code>rotation</code> channel.</p>

<p>Each of these channels accepted an integer from 0 - 255 (8-bit encoding).</p>

<p>In the case of each of the colors (red, blue, green), the integers <a href="http://en.wikipedia.org/wiki/RGB_color_model#Additive_primary_colors">represented the color amounts</a> -- for example, <code>red, green, blue = 0, 0, 255</code> would make a light shine pure blue light. <code>red, green, blue = 100, 0, 155</code> would probably result in some shade of purple light.</p>

<p>For the brightness parameter, the 0 - 255 scale was pretty intuitive: 0 meant off, 255 was the brightest the light would go.</p>

<p>And for the special case, the 0 - 255 scale represented the speed of rotation, from off to the fastest it would rotate, about once per second or so (this light also has a flashing option as well as rotation of the beams, but we decided not to include that as an option because the flashing, like strobe lighting, is annoying if not dangerous-for-some).</p>

<p>All five of these lights were hooked up to the Pi and all the appropriate information sent to them, via the Pi. (Of course, being allowed to turn on the rotate option does not make sense if the special case is turned off, but we decided to overlook that for two reasons: (a) the users were only those of us making it, and especially (b) turning rotate on and the special case off was senseless, but would not break anything.)</p>

<h2>the how</h2>

<p>We needed to create the server:</p>

<p>{% codeblock lang:python %}
import SocketServer</p>

<p>class MyTCPHandler(SocketServer.StreamRequestHandler):</p>

<pre><code>def handle(self):
    # self.rfile is a file-like object created by the handler
    # we can now use e.g. readline() instead of raw recv() calls
    self.data = self.rfile.readline().strip()
    print self.data # see what's going on
    list_vals = [int(x) for x in self.data.split(",")]
    lights_start(*list_vals)
    # Likewise, self.wfile is a file-like object used to write back to the client
    self.wfile.write("YES") # acknowledge something's happening
</code></pre>

<p>{% endcodeblock %}</p>

<p>The function in line 10 there, and the functionality from lines 7-9, I'll address shortly.</p>

<p>And at the bottom of the script,</p>

<p>{% codeblock lang:python %}
HOST, PORT = "0.0.0.0", 9999</p>

<h1>Create the server, binding to localhost on port 9999</h1>

<p>server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)</p>

<p>server.serve_forever()
{% endcodeblock %}</p>

<p>We also needed to use the <a href="http://www.opendmx.net/index.php/OLA_Python_API">OLA Python API</a> to deal with DMX, which was a simple matter of inspecting and copying over code.</p>

<p>At the top of the file,</p>

<p>{% codeblock lang:python %}
import array # data must be transmitted to DMX in an array
from ola.ClientWrapper import ClientWrapper
{% endcodeblock %}</p>

<p>And then, to instantiate a ClientWrapper for OLA and defining a function to deal with it:</p>

<p>{% codeblock lang:python %}
wrapper = ClientWrapper()</p>

<p>def DmxSent(state):</p>

<pre><code>wrapper.Stop()
</code></pre>

<p>{% endcodeblock %}</p>

<p>Next, a function to turn on the lights. We assumed we would always want the same color coming from each of the four (or five) lights.</p>

<p>Per the DMX specifications, the data structure we needed to pass was an array (a real array, not a Python list) with values in order for each lights. So the first four integer values in the array corresponded to the values for one normal light: <em>brightness, red, green, blue</em> values. The second would be the same four values, for the second normal light, etc. The special case light came last, in the order <em>brightness, red, green, blue, rotation</em>.</p>

<p>But just appending one after another was easy to lose track of and not pretty. Hence the function:</p>

<p>{% codeblock lang:python %}
def lights_do(bright, red, green, blue, rotate, sp): # the sp parameter is 0 or 1 and indicates whether the special case light goes on or not</p>

<pre><code>universe = 1 # this is required by DMX -- the lights are essentially attributes of 'universe 1'
data = array.array('B') # also required; see the OLA Python API specs
light_data = [bright, red, green, blue, rotate]
normal_light = light_data[:-1] # for extra clarity
tmp = [data.append(x) for x in normal_light*4]
if sp == 1:
    tmp = [data.append(x) for x in light_data]

client = wrapper.Client() # wrapper, above, is global in this script
client.SendDmx(universe, data, DmxSent)
wrapper.Run()
</code></pre>

<p>{% endcodeblock %}</p>

<p>The use of previously assigned global variables is a little cringe-worthy, but it achieved our purpose, and while I'll make arguments for good practices all the time, the goal of this project was nifty colored lights, to be perfectly honest. Now that we know it works, we'll do some brief polishing (both on the script and the wiring ends, but especially on the interface -- these are in progress).</p>

<p><code>tmp</code> here is obviously a throwaway variable. But the list comprehensions in lines 7 and 9 in that snippet earned me a "that syntax is <em>slick</em>, I admit" from my not-so-much-a-Python-programmer friend. List comprehensions, they are excellent.</p>

<p>It's extremely explicit code in many ways, allowing for Pythonic syntax like the list comprehensions, but I think there's value in that kind of explicitness.</p>

<p>Finally, we needed a wrapper function to handle whether or not the special case was on, so everything would go off or on as appropriate before passing new values to the lights to turn them on/change properties of the input channels (e.g. color, brightness).</p>

<p>{% codeblock lang:python %}</p>

<p>def lights_start(bright,red,green,blue,rotate,sp):</p>

<pre><code>lights_do(0,0,0,0,0,1)
lights_do(bright,red,green,blue,rotate,sp)
</code></pre>

<p>{% endcodeblock %}</p>

<p>So, let's go back to the <code>handle()</code> method of the <code>MyTCPHandler</code> class:</p>

<p>{% codeblock lang:python %}
def handle(self):</p>

<pre><code># self.rfile is a file-like object created by the handler
# we can now use e.g. readline() instead of raw recv() calls
self.data = self.rfile.readline().strip()
print self.data # see what's going on
list_vals = [int(x) for x in self.data.split(",")]
lights_start(*list_vals)
# Likewise, self.wfile is a file-like object used to write back to the client
self.wfile.write("YES") # acknowledge something's happening
</code></pre>

<p>{% endcodeblock %}</p>

<p>When this script is served on the Raspberry Pi, wired to the lights in question, it can accept input from a client.</p>

<p>So this <code>handle()</code> method gets data: <code>self.data</code> .</p>

<p>We expect this to be a comma-separated string of six integer values: <code>bright, red, green, blue, rotate, sp</code> , as seen in <code>lights_start()</code> and <code>lights_do()</code> (above).</p>

<p>In line 4 in the snippet just above, <code>self.data = self.rfile.readline().strip()</code>, we take the arguments from the client and make them into a string stripped of whitespace on either end.</p>

<p>In line 6, <code>list_vals = [int(x) for x in self.data.split(",")]</code>, we split the string at the commas, into a list, making a list e.g. <code>['255','0','255','0','0','1']</code>. But each element of this list is of type <code>String</code>, so we use list comprehension syntax to make <code>list_vals</code> a list of integers (DMX expects integer values).</p>

<p>And in line 7, we call the function <code>lights_start()</code>, the wrapper function seen further above, which prepares to call <code>lights_do()</code> with any appropriate new values. We call it with the values passed to the server from the client: <code>*list_vals</code> is Python syntax to "unpack" an iterable like a list.</p>

<h2>the interface</h2>

<p>Wanting to make a quick web interface for sending the colors to the Pi server, we looked for a color picker wheel in JavaScript. Soon, the internet informed us that <code>color</code> is a built-in input value in HTML5.</p>

<p>"SWEET," I said. So, a hasty HTML form (we weren't playing designers here):</p>

<p>{% codeblock lang:html %}
<head></p>

<pre><code>&lt;title&gt;Pick a color&lt;/title&gt;
</code></pre>

<p></head>
<body></p>

<pre><code>&lt;form action="light.php" method="post"&gt;
    Choose Color:&lt;br&gt;
    &lt;input type="color" name="color"&gt;
    &lt;br&gt;
    Brightness:
    &lt;br&gt;
    &lt;input type="text" name="bright" value="255"&gt;
    &lt;br&gt;
    &lt;input type="submit" value="submit"&gt;
&lt;/form&gt;
</code></pre>

<p></body>
{% endcodeblock %}</p>

<p>In the browser, this looks like:</p>

<p>{% img http://jaclynzetta.files.wordpress.com/2013/04/colorform_remotelighting.png %}</p>

<p>We chose 255 as a default brightness, because that seemed overall most likely, and 0 -- black, or off, as a 'default' for all the color inputs.</p>

<p>(The special case options are not yet dealt with well in the interface, but that's easy enough to add, as would be a dropdown menu or slider for the brightness value, which here is just a text entry.)</p>

<p>That would get us a hex color value. We would need to convert that value to RGB. (The 0-255 integer values determining the colors -- of course, the input values for <code>red, green, blue</code> must always add up to 255 in total.) We decided to use PHP (mainly because my expertise, with regards to languages we used, was in Python, and my friend's, in PHP):</p>

<p>{% codeblock lang:php %}
function hex2rgb($hex) {
   $hex = str_replace("#", "", $hex);</p>

<p>   if(strlen($hex) == 3) {</p>

<pre><code>  $r = hexdec(substr($hex,0,1).substr($hex,0,1));
  $g = hexdec(substr($hex,1,1).substr($hex,1,1));
  $b = hexdec(substr($hex,2,1).substr($hex,2,1));
</code></pre>

<p>   } else {</p>

<pre><code>  $r = hexdec(substr($hex,0,2));
  $g = hexdec(substr($hex,2,2));
  $b = hexdec(substr($hex,4,2));
</code></pre>

<p>   }
   $rgb = array($r, $g, $b);
   //return implode(",", $rgb); // returns the rgb values separated by commas
   return $rgb; // returns an array with the rgb values
}
{% endcodeblock %}</p>

<p>So if a color was chosen on the interface, then we wanted to POST that RGB information, and whatever brightness was selected, to the server:</p>

<p>{% codeblock lang:php %}
if ($_POST['color']) { // if-statement begins</p>

<pre><code>$color = hex2rgb($_POST['color']);
$bright = $_POST['bright'];
</code></pre>

<p>{% endcodeblock %}</p>

<p>and, still in this if-statement, turn the returned array from <code>hex2rgb()</code> to a string separated by commas. The quick-n-dirty way:</p>

<p>{% codeblock lang:php %}</p>

<pre><code>$out = $bright . ',' . $color[0] . ',' . $color[1] . ',' . $color[2] . ',255,0';
</code></pre>

<p>{% endcodeblock %}</p>

<p>Then we create a file pointer to the open socket, and pass it the IP address of the Raspberry Pi and the appropriate port (which in our case, as you can see earlier in the post, was port 9999):</p>

<p>{% codeblock lang:php %}</p>

<pre><code>$fp = fsockopen('xxx.xxx.xx.xx','9999'); // x-es represent the pi IP
</code></pre>

<p>{% endcodeblock %}</p>

<p>And write it to the server:</p>

<p>{% codeblock lang:php %}</p>

<pre><code>fwrite($fp, $out);
</code></pre>

<p>} // if-statement ends here
{% endcodeblock %}</p>

<p>Hooray! I don't have pictures, but it was pretty great.</p>

<p>We had a lot of fun with this project, and I think it's only made better by the facts that (a) we said 'hey, let's do this' and went and made it happen, and (b) this kind of reasonably simple affecting one's physical environment in fun ways using capabilities of a <a href="http://www.raspberrypi.org/faqs">Raspberry Pi</a> is, like the workshop with LEDs and photo sensors I briefly referred to the other day, a great way to show kids the possibilities that are available by learning a little bit about electronics and programming. Which are also GREAT, oh man.</p>

<p>Here's where the value I mentioned in explicit code comes in: it's great that it's easy to read what's happening without shoving too much information into one line, but it's even better that this makes it easy to explain, and thus easier to teach.</p>
]]></content>
  </entry>
  
</feed>
