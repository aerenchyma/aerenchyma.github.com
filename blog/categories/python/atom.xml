<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | everything's interesting]]></title>
  <link href="http://aerenchyma.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://aerenchyma.github.com/"/>
  <updated>2013-10-21T15:26:52-04:00</updated>
  <id>http://aerenchyma.github.com/</id>
  <author>
    <name><![CDATA[Jackie Cohen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Recipe formatting]]></title>
    <link href="http://aerenchyma.github.com/blog/2013/07/15/recipe-formatting/"/>
    <updated>2013-07-15T18:21:00-04:00</updated>
    <id>http://aerenchyma.github.com/blog/2013/07/15/recipe-formatting</id>
    <content type="html"><![CDATA[<h2>the what</h2>

<p>Almost four years ago, I was having a discussion with a friend about recipes: we determined that ideally, ingredient amounts should be integrated into recipe directions as well as in a list at the beginning of the recipe for shopping/gathering/whatever. Rather than looking at "Now, add rice vinegar" and flipping gaze back to the beginning to see just how much, it should say "add 1/4 cup rice vinegar" right in the instructions.</p>

<p>We talked about compiling recipes this way, about indexing them in useful ways; by ingredient, dietary preference alignment, allergy compliance, and how you should scale them for a thirty-person cooperative. I thought about doing it programmatically; I'd begun to learn Python a few months before. I shook my head, at the time: it sounded so difficult, and I thought maybe later.</p>

<p>A few weeks ago, it seemed a lot more doable. The overhead on web scraping feels lighter now: I've done it a whole lot more. My attitude toward solving problems is neither less nor more enthusiastic four years later (freaking love 'em then and now) but it is significantly more confident. I felt that the problem would be less overwhelming now.</p>

<p>Less overwhelming, perhaps. It still turns out to be hard.</p>

<!-- more -->


<p>But it's a fun problem, and an interesting one, because challenging pieces continue to rise to the surface -- not as sudden "oh, crap!" surprises, but slowly looming challenges of various size.</p>

<p>I decided to attempt only parsing recipes from the site <a href="http://www.allrecipes.com">AllRecipes</a>, in order to be able to scrape reliably and not turn it into as much of a Machine Learning problem (what's an ingredient, etc) or add another layer of a parsing problem to the challenge. Even with this limit, it's not <em>easy</em>. (A few issues remain unsolved with the method I used.)</p>

<h2>the how</h2>

<p>I wrote my current attempt in Python, doing the scraping with <a href="https://beautiful-soup-4.readthedocs.org/en/latest/">BeautifulSoup</a>.</p>

<p>Most of it is currently being done via a procedural script. I use one helper function that I call <code>word_sans_comma(w)</code> in order to strip words of punctuation non-destructively, needing a function because strings are, of course, immutable in Python.</p>

<p>To test, I save the brief version of an AllRecipes URL in a <code>test_recipe</code> variable to save me typing or entering otherwise. I tested several recipes, with different ingredients, to try and catch bugs, which I'll address shortly. For one example, there's <code>http://allrecipes.com/Recipe/Chicken-Pot-Pie-IX/</code>.</p>

<p>I also have pre-compiled lists of words, which need to be gathered in more responsible ways: stopwords (things like "in", "on", "and"; words that don't add much to meaning individually and don't help in searches), meat words (e.g. "chicken" or "beef", words that indicate there are meat products in the recipe), dairy words (I assume we get the picture), and other non-vegan words which don't fall into any of the former categories (right now only including "egg" -- I welcome other suggestions).</p>

<p>I open the recipe page and create a <code>soup</code> instance with BeautifulSoup, pull out the title and the number of servings. I find the part of the page that lists ingredients with <code>test_ingr = rec_doc.findAll("p", {"class" : "fl-ing"})</code>. (See <a href="https://github.com/aerenchyma/allrecipe_parsing">the code</a>.) Or in English, <em>find all the occurrences of <code>&lt;p class="fl-ing"&gt;&lt;/p&gt;</code> tags on the page.</em></p>

<p>I iterate through the list I get in <code>test_ingr</code>, and if it includes a name and a discrete amount (1/2 cup, 1 pinch, whatever -- they're all labeled with the HTML id <code>lblIngAmount</code>, while the ingredient names all are wrapped within a tag id'd <code>lblIngName</code>), I add these things to a Python dictionary of ingredients where the Key:Value pairs are Ingredient-Name:Ingredient-Amount.</p>

<p>Using <code>.findAll()</code> means I will get a return value of a Python list, so right there I have what I need: each of the ingredients, with their respective amounts.</p>

<p>The ingredient directions on AllRecipes recipes are wrapped in their own <code>div</code>. I split up the directions into words with Python's <code>.split()</code>, and iterate through the non-stopwords in the resulting list. I am concerned with a few things during this iteration:</p>

<ol>
<li><p>I avoid all simple past verbs (many things can be "chopped" or "sliced" so it worked best not to consider these when looking for places in the directions where amounts or fuller ingredient descriptions needed to be inserted).</p></li>
<li><p>Whether my boolean variables <code>vegan</code> and <code>non-dairy</code> should be turned False: are any of these words in my meat words or dairy words lists? (Common allergies are another set of categories I'm likely to add in the future.)</p></li>
<li><p>In a show of relatively poor performance (only speedwise -- it detracts from the speed of a run, but not noticeably for these purposes{% fn_ref 1 %}), I loop through the ingredients in the dictionary of ingredients I created earlier, in a nested loop.</p></li>
</ol>


<p>I split each ingredient name into a Python list of individual words and compare these words, without punctuation (using my <code>word_sans_comma(w)</code> function), to each relevant word in the ingredient directions. If it's a match, I replace that word in the directions with the string composed of [INGREDIENT AMOUNT] + [INGREDIENT NAME (as listed in the original ingredients dictionary)], correct for punctuation as needed, and fix punctuation issues. For example, if the directions state</p>

<p><code>stir in the pasta, then add the lemon</code></p>

<p>you'd want that comma, e.g. <code>stir in the 1/2 lb of whole wheat pasta, then ...</code> is better than <code>stir in the 1/2 lb of whole wheat pasta then add the lemon</code>. The former reads more clearly (to me, anyway).</p>

<p>I need that <code>word_sans_comma</code> function in order to compare words without attached punctuation to other similarly unencumbered words, but retain the original, punctuation-ful strings for the final result. It'd be pretty ugly to take out all the commas and periods from a recipe in order to insert ingredient amounts in the directions. The varying ways in which punctuation is used contributes to a lot of hard and interesting linguistics problems (not only computational), and it certainly contributes here. Among others, <a href="http://books.google.com/books/about/The_Linguistics_of_Punctuation.html?id=Sh-sruuKjJwC">Geoffrey Nunberg wrote about this</a>.</p>

<p>Finally, if any words remain doubled, I remove one of the occurrences of the word. For example, if the directions read <code>take the chicken, chopped ...</code> then replacing that to result in <code>take the 2 chicken breasts, chopped chopped</code> is unfortunate.</p>

<p>I separate the sentences in the directions into lines, and write the recipe title, dietary preference categories, serving number, and enhanced line-by-line directions to a file.</p>

<p>(I'm still deciding on what I want my LaTeX template for these purposes to look like, so at the moment it's a text file, but a much clearer text file than the print version of most of these recipes.)</p>

<p>Upcoming: pretty TeX, better indexing, allergy categorization, hosting, removal of awkwardness (e.g. replacing the phrase "parsley" with "1/2 cup freshly chopped, bright green parsley" six times in a row -- it's not <em>necessarily</em> inaccurate, but it's certainly annoying), and an issues list on GitHub to keep track of these things outside my personal issue tracker.</p>

<p>You can see the code <a href="https://github.com/aerenchyma/allrecipe_parsing">here</a>.</p>

<h2>the issues</h2>

<p>In discussions with variously similarly-minded people, most of the solutions proposed for this problem of re-laying-out AllRecipes' recipes are either much like mine, involve using a full parser, or involve employing a variety of minimum edit distance in combination with part of my solution. Each of these ideas for solutions offer their own advantages and their own problems. Most notably, I think, none makes it easy, and none seems to make the problems invisible.</p>

<p>The most significant issues remaining in mine are three (or four, depending upon how you separate them).</p>

<ul>
<li><strong>Clarity.</strong></li>
</ul>


<p>The example I gave earlier about chopped chicken and accidental word-reduplication is sometimes particularly problematic. What if the original recipe states <code>put the chopped chicken in the pan</code> and the ingredient list includes <code>2 chicken breasts, chopped</code>? The current algorithm may result in <code>put the chopped 2 chicken breasts, chopped</code>. Bad.</p>

<p>With the current algorithm, replacing also occurs in places it ought not, creating some problematic sentences (this problem often overlaps with the awkwardness of multiple insertions of a long ingredient phrase that I refer to above). My favorite resulting gem: <em>Continue baking until cheese is melted and 4 skinless, boneless chicken breast halves juices run clear</em>.</p>

<p>Yay, evaluation.</p>

<ul>
<li><strong>Amount separation.</strong></li>
</ul>


<p>This algorithm does not account at all for occurrences of splitting up an amount of a single type of ingredient. For example, if a recipe calls for 2 cups of sugar but has you <em>stir in 1.5 cups of sugar</em> at the beginning of the process, then <em>sprinkle 1/2 cup of sugar</em> on top at the end of the preparations, this will turn your recipe pretty confusing.</p>

<ul>
<li><strong>Overlapping names.</strong></li>
</ul>


<p>Celery and celery seed are two different ingredients. Until common bigrams (or better parsing mechanisms?) are implemented, this code will treat both occurrences of the word "celery" the same, though. You'll see this, if you try the chicken pot pie recipe. I tilted my head at it for a moment and then laughed, adding to the list.</p>

<p>This happens only when the shared token ("celery", in this case) comes first in a phrase: for instance, it's fine if a recipe includes both <em>shredded mozzarella</em> and <em>smoked mozzarella</em>{% fn_ref 2 %}, because replacing happens on first occurrence. This is a Big Bad Problem, but I found it interesting that it came up as late as it did; it's not a terribly unusual case.</p>

<h2>takeaways</h2>

<ul>
<li><p>Even if you're really familiar with a language, its gotchas may still get you. (I spent more than a second wondering why Python's <code>.replace()</code> was working the way it was, though I've probably used it thousands of times.)</p></li>
<li><p>Tiny human problems are often fun ones: I can't honestly say that I've used this often in the weeks since it's existed on my hard drive, but I've used it more than once -- and I've certainly thought about it.</p></li>
<li><p>Language is amazing. NLP, and issues I've thought about and written about as both a linguist and a programmer repeatedly arise, even when I don't come at a problem thinking it's a <em>language parsing problem</em>. A <em>lot</em> of things are language parsing problems, I am finding. Recipes rely so much on human knowledge! Every day I come up with a new angle on my senior thesis from years ago (that's another story entirely).</p></li>
<li><p>Evaluation is a hard problem. When I told people about this and they proposed a different solution, I spent a couple minutes thinking <em>oh, duh</em> -- and realized it wasn't obvious at all. Maybe their solutions result in problems that generate less confusion, or less amusement (that's an inclusive OR). Certainly there are more elegant ways to write this, in fewer lines of code, such that it will run faster, relying on different architecture. But none of them solve everything, insofar as I can tell, without more time. It's not a snap-your-fingers-problem.</p></li>
<li><p>And I've learned a lot. I couldn't do this in any kind of hasty side-project kinda way four years ago: I wasn't comfortable enough just <em>playing.</em> It seemed so serious, like so much to hold in your head. It may not be a simple problem exactly but it isn't overwhelming anymore. I've had a lot of fun discussions about this; the best part, probably, was comparing solutions, because it was possible to hold them in my head and compare them piece-by-piece. It's a, if not <em>the</em>, way I think project-based-learning should go.</p></li>
</ul>


<hr />

<p>{% footnotes %}
{% fn %} But it's important to be aware I'm doing more looping than necessary -- it's a TODO. I think it's sometimes fun to make things work without immediate concern about performance, but I hesitate to phrase it that way, because it falsely implies that optimizing code isn't fun. Let's just say I'm gettin' there.
{% fn %} Assuming, for the sake of this example, that each of these mozzerellas is intended for a different end within the relevant concoction.
{% endfootnotes %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[remote lighting]]></title>
    <link href="http://aerenchyma.github.com/blog/2013/04/21/remote-lighting/"/>
    <updated>2013-04-21T12:01:00-04:00</updated>
    <id>http://aerenchyma.github.com/blog/2013/04/21/remote-lighting</id>
    <content type="html"><![CDATA[<p>This past Friday, I joined forces with a friend for a fun remote lighting project using a Raspberry Pi.</p>

<p>Remote lighting? you say. You know the colored stage lights you see in theatres? If you ever did tech for a production in high school in a small theatre without super-intense equipment, those are the ones we used. They were hooked up via <a href="http://en.wikipedia.org/wiki/DMX_(lighting">DMX</a> ). (See <a href="http://www.opendmx.net/index.php/OLA_Python_API">here</a> for more information about the Python API, which we used.)</p>

<p>Some of these lights were hooked up to a Pi, and the idea was that we would be able to pass a color (e.g. on a color wheel like you might see in Photoshop), and brightness, via a web interface, which would then set the lights on as specified.</p>

<p>Below is the how and the what, and the code. All you need to make this happen is the appropriate lights and wiring (I didn't do this part, so I can't speak to it), a Raspberry Pi, set up with wireless, and a computer with monitor and keyboard input/a laptop that can also access the wireless network.</p>

<!--more-->


<h2>the setup</h2>

<p>We had 4 "normal" lights, and 1 special case light. Each of the four normal lights had four input/output channels. The fifth "special case" light had five channels.</p>

<p>All of them had channels <code>brightness</code>, <code>red</code>, <code>blue</code>, and <code>green</code>. The special case light (a light sort of but not exactly like <a href="http://www.alibaba.com/product-gs/693385417/DMX_18x10W_RGBW_4IN1_Multi_color.html">this</a>) had these four channels, plus a <code>rotation</code> channel.</p>

<p>Each of these channels accepted an integer from 0 - 255 (8-bit encoding).</p>

<p>In the case of each of the colors (red, blue, green), the integers <a href="http://en.wikipedia.org/wiki/RGB_color_model#Additive_primary_colors">represented the color amounts</a> -- for example, <code>red, green, blue = 0, 0, 255</code> would make a light shine pure blue light. <code>red, green, blue = 100, 0, 155</code> would probably result in some shade of purple light.</p>

<p>For the brightness parameter, the 0 - 255 scale was pretty intuitive: 0 meant off, 255 was the brightest the light would go.</p>

<p>And for the special case, the 0 - 255 scale represented the speed of rotation, from off to the fastest it would rotate, about once per second or so (this light also has a flashing option as well as rotation of the beams, but we decided not to include that as an option because the flashing, like strobe lighting, is annoying if not dangerous-for-some).</p>

<p>All five of these lights were hooked up to the Pi and all the appropriate information sent to them, via the Pi. (Of course, being allowed to turn on the rotate option does not make sense if the special case is turned off, but we decided to overlook that for two reasons: (a) the users were only those of us making it, and especially (b) turning rotate on and the special case off was senseless, but would not break anything.)</p>

<h2>the how</h2>

<p>We needed to create the server:</p>

<p>{% codeblock lang:python %}
import SocketServer</p>

<p>class MyTCPHandler(SocketServer.StreamRequestHandler):</p>

<pre><code>def handle(self):
    # self.rfile is a file-like object created by the handler
    # we can now use e.g. readline() instead of raw recv() calls
    self.data = self.rfile.readline().strip()
    print self.data # see what's going on
    list_vals = [int(x) for x in self.data.split(",")]
    lights_start(*list_vals)
    # Likewise, self.wfile is a file-like object used to write back to the client
    self.wfile.write("YES") # acknowledge something's happening
</code></pre>

<p>{% endcodeblock %}</p>

<p>The function in line 10 there, and the functionality from lines 7-9, I'll address shortly.</p>

<p>And at the bottom of the script,</p>

<p>{% codeblock lang:python %}
HOST, PORT = "0.0.0.0", 9999</p>

<h1>Create the server, binding to localhost on port 9999</h1>

<p>server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)</p>

<p>server.serve_forever()
{% endcodeblock %}</p>

<p>We also needed to use the <a href="http://www.opendmx.net/index.php/OLA_Python_API">OLA Python API</a> to deal with DMX, which was a simple matter of inspecting and copying over code.</p>

<p>At the top of the file,</p>

<p>{% codeblock lang:python %}
import array # data must be transmitted to DMX in an array
from ola.ClientWrapper import ClientWrapper
{% endcodeblock %}</p>

<p>And then, to instantiate a ClientWrapper for OLA and defining a function to deal with it:</p>

<p>{% codeblock lang:python %}
wrapper = ClientWrapper()</p>

<p>def DmxSent(state):</p>

<pre><code>wrapper.Stop()
</code></pre>

<p>{% endcodeblock %}</p>

<p>Next, a function to turn on the lights. We assumed we would always want the same color coming from each of the four (or five) lights.</p>

<p>Per the DMX specifications, the data structure we needed to pass was an array (a real array, not a Python list) with values in order for each lights. So the first four integer values in the array corresponded to the values for one normal light: <em>brightness, red, green, blue</em> values. The second would be the same four values, for the second normal light, etc. The special case light came last, in the order <em>brightness, red, green, blue, rotation</em>.</p>

<p>But just appending one after another was easy to lose track of and not pretty. Hence the function:</p>

<p>{% codeblock lang:python %}
def lights_do(bright, red, green, blue, rotate, sp): # the sp parameter is 0 or 1 and indicates whether the special case light goes on or not</p>

<pre><code>universe = 1 # this is required by DMX -- the lights are essentially attributes of 'universe 1'
data = array.array('B') # also required; see the OLA Python API specs
light_data = [bright, red, green, blue, rotate]
normal_light = light_data[:-1] # for extra clarity
tmp = [data.append(x) for x in normal_light*4]
if sp == 1:
    tmp = [data.append(x) for x in light_data]

client = wrapper.Client() # wrapper, above, is global in this script
client.SendDmx(universe, data, DmxSent)
wrapper.Run()
</code></pre>

<p>{% endcodeblock %}</p>

<p>The use of previously assigned global variables is a little cringe-worthy, but it achieved our purpose, and while I'll make arguments for good practices all the time, the goal of this project was nifty colored lights, to be perfectly honest. Now that we know it works, we'll do some brief polishing (both on the script and the wiring ends, but especially on the interface -- these are in progress).</p>

<p><code>tmp</code> here is obviously a throwaway variable. But the list comprehensions in lines 7 and 9 in that snippet earned me a "that syntax is <em>slick</em>, I admit" from my not-so-much-a-Python-programmer friend. List comprehensions, they are excellent.</p>

<p>It's extremely explicit code in many ways, allowing for Pythonic syntax like the list comprehensions, but I think there's value in that kind of explicitness.</p>

<p>Finally, we needed a wrapper function to handle whether or not the special case was on, so everything would go off or on as appropriate before passing new values to the lights to turn them on/change properties of the input channels (e.g. color, brightness).</p>

<p>{% codeblock lang:python %}</p>

<p>def lights_start(bright,red,green,blue,rotate,sp):</p>

<pre><code>lights_do(0,0,0,0,0,1)
lights_do(bright,red,green,blue,rotate,sp)
</code></pre>

<p>{% endcodeblock %}</p>

<p>So, let's go back to the <code>handle()</code> method of the <code>MyTCPHandler</code> class:</p>

<p>{% codeblock lang:python %}
def handle(self):</p>

<pre><code># self.rfile is a file-like object created by the handler
# we can now use e.g. readline() instead of raw recv() calls
self.data = self.rfile.readline().strip()
print self.data # see what's going on
list_vals = [int(x) for x in self.data.split(",")]
lights_start(*list_vals)
# Likewise, self.wfile is a file-like object used to write back to the client
self.wfile.write("YES") # acknowledge something's happening
</code></pre>

<p>{% endcodeblock %}</p>

<p>When this script is served on the Raspberry Pi, wired to the lights in question, it can accept input from a client.</p>

<p>So this <code>handle()</code> method gets data: <code>self.data</code> .</p>

<p>We expect this to be a comma-separated string of six integer values: <code>bright, red, green, blue, rotate, sp</code> , as seen in <code>lights_start()</code> and <code>lights_do()</code> (above).</p>

<p>In line 4 in the snippet just above, <code>self.data = self.rfile.readline().strip()</code>, we take the arguments from the client and make them into a string stripped of whitespace on either end.</p>

<p>In line 6, <code>list_vals = [int(x) for x in self.data.split(",")]</code>, we split the string at the commas, into a list, making a list e.g. <code>['255','0','255','0','0','1']</code>. But each element of this list is of type <code>String</code>, so we use list comprehension syntax to make <code>list_vals</code> a list of integers (DMX expects integer values).</p>

<p>And in line 7, we call the function <code>lights_start()</code>, the wrapper function seen further above, which prepares to call <code>lights_do()</code> with any appropriate new values. We call it with the values passed to the server from the client: <code>*list_vals</code> is Python syntax to "unpack" an iterable like a list.</p>

<h2>the interface</h2>

<p>Wanting to make a quick web interface for sending the colors to the Pi server, we looked for a color picker wheel in JavaScript. Soon, the internet informed us that <code>color</code> is a built-in input value in HTML5.</p>

<p>"SWEET," I said. So, a hasty HTML form (we weren't playing designers here):</p>

<p>{% codeblock lang:html %}
<head></p>

<pre><code>&lt;title&gt;Pick a color&lt;/title&gt;
</code></pre>

<p></head>
<body></p>

<pre><code>&lt;form action="light.php" method="post"&gt;
    Choose Color:&lt;br&gt;
    &lt;input type="color" name="color"&gt;
    &lt;br&gt;
    Brightness:
    &lt;br&gt;
    &lt;input type="text" name="bright" value="255"&gt;
    &lt;br&gt;
    &lt;input type="submit" value="submit"&gt;
&lt;/form&gt;
</code></pre>

<p></body>
{% endcodeblock %}</p>

<p>In the browser, this looks like:</p>

<p>{% img http://jaclynzetta.files.wordpress.com/2013/04/colorform_remotelighting.png %}</p>

<p>We chose 255 as a default brightness, because that seemed overall most likely, and 0 -- black, or off, as a 'default' for all the color inputs.</p>

<p>(The special case options are not yet dealt with well in the interface, but that's easy enough to add, as would be a dropdown menu or slider for the brightness value, which here is just a text entry.)</p>

<p>That would get us a hex color value. We would need to convert that value to RGB. (The 0-255 integer values determining the colors -- of course, the input values for <code>red, green, blue</code> must always add up to 255 in total.) We decided to use PHP (mainly because my expertise, with regards to languages we used, was in Python, and my friend's, in PHP):</p>

<p>{% codeblock lang:php %}
function hex2rgb($hex) {
   $hex = str_replace("#", "", $hex);</p>

<p>   if(strlen($hex) == 3) {</p>

<pre><code>  $r = hexdec(substr($hex,0,1).substr($hex,0,1));
  $g = hexdec(substr($hex,1,1).substr($hex,1,1));
  $b = hexdec(substr($hex,2,1).substr($hex,2,1));
</code></pre>

<p>   } else {</p>

<pre><code>  $r = hexdec(substr($hex,0,2));
  $g = hexdec(substr($hex,2,2));
  $b = hexdec(substr($hex,4,2));
</code></pre>

<p>   }
   $rgb = array($r, $g, $b);
   //return implode(",", $rgb); // returns the rgb values separated by commas
   return $rgb; // returns an array with the rgb values
}
{% endcodeblock %}</p>

<p>So if a color was chosen on the interface, then we wanted to POST that RGB information, and whatever brightness was selected, to the server:</p>

<p>{% codeblock lang:php %}
if ($_POST['color']) { // if-statement begins</p>

<pre><code>$color = hex2rgb($_POST['color']);
$bright = $_POST['bright'];
</code></pre>

<p>{% endcodeblock %}</p>

<p>and, still in this if-statement, turn the returned array from <code>hex2rgb()</code> to a string separated by commas. The quick-n-dirty way:</p>

<p>{% codeblock lang:php %}</p>

<pre><code>$out = $bright . ',' . $color[0] . ',' . $color[1] . ',' . $color[2] . ',255,0';
</code></pre>

<p>{% endcodeblock %}</p>

<p>Then we create a file pointer to the open socket, and pass it the IP address of the Raspberry Pi and the appropriate port (which in our case, as you can see earlier in the post, was port 9999):</p>

<p>{% codeblock lang:php %}</p>

<pre><code>$fp = fsockopen('xxx.xxx.xx.xx','9999'); // x-es represent the pi IP
</code></pre>

<p>{% endcodeblock %}</p>

<p>And write it to the server:</p>

<p>{% codeblock lang:php %}</p>

<pre><code>fwrite($fp, $out);
</code></pre>

<p>} // if-statement ends here
{% endcodeblock %}</p>

<p>Hooray! I don't have pictures, but it was pretty great.</p>

<p>We had a lot of fun with this project, and I think it's only made better by the facts that (a) we said 'hey, let's do this' and went and made it happen, and (b) this kind of reasonably simple affecting one's physical environment in fun ways using capabilities of a <a href="http://www.raspberrypi.org/faqs">Raspberry Pi</a> is, like the workshop with LEDs and photo sensors I briefly referred to the other day, a great way to show kids the possibilities that are available by learning a little bit about electronics and programming. Which are also GREAT, oh man.</p>

<p>Here's where the value I mentioned in explicit code comes in: it's great that it's easy to read what's happening without shoving too much information into one line, but it's even better that this makes it easy to explain, and thus easier to teach.</p>
]]></content>
  </entry>
  
</feed>
